Doron Reid  
Object Oriented Development Assignment 3 Reflection

Assignment 2 and assignment 3 implements a Extract–Transform–Load (ETL) pipeline in Java. Both assignments are required to read a product data CSV file, apply transformation rules, and write the results to a new CSV file. Both assignments follow the same logic producing the same output, but the overall structure of the two implementations are quite different. Originally, I implemented assignment 2 in a procedural style within a single class. With assistance from generative AI to brainstorm new implementations, assignment 3 was refactored into a fully object-oriented architecture with clear separation of responsibilities amongst the classes.   
All functionality in assignment 2 was in one public class, ETLPipeline. That class handled file reading logic, row validation, transformation rules, output file writing, summary statistics, and even included a static inner class called TransformedRow to store processed data. Each of these logics were implemented inside the main method.​​​ This approach worked perfectly well, but it's simply a large and complex method that manages multiple responsibilities simultaneously. This design actually violates the Single Responsibility Principle due to one class being responsible for reading data, transforming it, and writing output.   
So to fulfill the requirement of making this design object-oriented, assignment 3 got broken down into six focused classes, each with a specific responsibility. The **Product** class represents the raw input data read from the CSV file, while the **TransformedProduct** class represents the processed data that will be written to the output file. There is a **ProductReader** class that handles file input and row validation, the **ProductTransformer** applies all required transformation rules, and the **ProductWrite** class manages writing the final results to a new CSV file. Finally, the **ETLPipeline** class acts as the master class, orchestrating the overall process by calling these other classes. The separation of responsibilities causes a cleaner design, easier maintenance, and fulfills object-oriented principles.  
Assignment 3 incorporates core object-oriented concepts to improve the structure and clarity of the program. I did use classes to model distinct responsibilities within the system,  such as reading input, transforming data, and writing output. Objects were created from these classes to represent real data entities, including both raw products and transformed products. Encapsulation was also applied to keep class fields private and provide controlled access through public methods, which protects the internal data and promotes modularity. The overall design supports future extensibility by organizing functionality into well-defined, independent components.  
To confirm assignment 3 works the same as assignment 2, I conducted the same series of controlled tests using the same data/products.csv input file for both implementations. In assignment 2, I saved the generated data/transformed\_products.csv file, then I deleted that output file and executed Assignment 3 using the identical input file. After comparing the two output files, the results were identical. The file showed the correct application of the 10% discount for Electronics, proper rounding of prices to two decimal places, accurate price range classification, appropriate handling of invalid rows, and correct reporting of row counts. In assignment 2 I failed to test the edge case of including an input file with the header still if there is a missing input file, but in assignment 3 that was fixed. In all scenarios, Assignment 3 demonstrated the same functional behavior as Assignment 2 while maintaining a more organized and object-oriented design.